#include "mat_writer.h"
#include "mat_writer_p.h"
#include <spdlog/fmt/ostr.h>
#include <spdlog/spdlog.h>

namespace mat
{
    std::ostream &operator<<(std::ostream &os, data_type t)
    {
        switch (t)
        {
        case data_type::int8:
            return os << "int8";
        case data_type::uint8:
            return os << "uint8";
        case data_type::int16:
            return os << "int16";
        case data_type::uint16:
            return os << "uint16";
        case data_type::int32:
            return os << "int32";
        case data_type::uint32:
            return os << "uint32";
        case data_type::float_single:
            return os << "float";
        case data_type::float_double:
            return os << "double";
        case data_type::matrix:
            return os << "matrix";
        case data_type::compressed:
            return os << "compressed";
        }

        return os << fmt::format("data_type({})", (int)t);
    }
    std::ostream &operator<<(std::ostream &str, const data_element &d)
    {
        spdlog::debug("Writing {} data element of size {}", d.type(), d.byte_size());

        uint32_t tmp = (uint32_t)d.type();
        char *p_cTmp = (char *)&tmp;

        str.write(p_cTmp, 4);
        tmp = d.byte_size();
        str.write(p_cTmp, 4);
        d.write(str);
        return str;
    }

    std::ostream &operator<<(std::ostream &str, const header &)
    {
        std::string text = "MATLAB 5.0 MAT-file. Generated by scope_receiver";
        text.resize(116);

        str.write(&*text.cbegin(), text.size());
        const char zeros[8] = {'\0'};
        uint16_t version = 0x0100;
        uint16_t BOM_mark = ('M' << 8) | 'I';

        str.write(zeros, 8);
        str.write((char *)&version, 2);
        str.write((char *)&BOM_mark, 2);
        return str;
    }

    uint32_t matrix::byte_size() const
    {
        return (
            // Flags array
            header_size() + 8 +
            // Dimenstions array
            header_size() + m_dimensions_array.size() * sizeof(uint32_t) +
            // name array
            header_size() + element<char>{nullptr, m_name.size()}.aligned_size() +
            // real data array
            header_size() + m_data.size() * 2 * sizeof(double) +
            // imaginary data array
            0);
    }

    void matrix::write(std::ostream &os) const
    {
        std::array<uint32_t, 2> flags;
        constexpr uint32_t F_COMPLEX = (1 << 11);
        constexpr uint32_t F_GLOBAL = (1 << 10);
        constexpr uint32_t F_LOGICAL = (1 << 9);
        constexpr uint32_t CLASS_DOUBLE = 6;

        flags[0] = CLASS_DOUBLE;
        flags[1] = 0;
        os << make_element(flags);
        os << make_element(m_dimensions_array);
        os << make_element<char>(m_name);
        os << make_element(m_data);
    }

    // std::ostream &operator<<(std::ostream &str, const matrix &matrix)
    // {
    //     uint32_t type = 0x0e; // matrix
    //     uint32_t size = 24 /* header size */ + 8 /* dimensions size */ + 8 /* name dimensions size */;
    //     size += matrix.name.size();
    //     size += (8 - matrix.name.size()) % 8;
    //     size += 8 /* data type and something? */;
    //     size += 16 * matrix.data.size();

    //     str.write((char *)&type, 4);
    //     str.write((char *)&size, 4);

    //     char some_headers[24] = {6, 0, 0, 0, 8, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 5, 0, 0, 0, 8, 0, 0, 0};
    //     str.write(some_headers, 24);

    //     uint32_t rows = 2;
    //     uint32_t cols = matrix.data.size();
    //     str.write((char *)&rows, 4);
    //     str.write((char *)&cols, 4);

    //     rows = 1;
    //     cols = matrix.name.size();
    //     str.write((char *)&rows, 4);
    //     str.write((char *)&cols, 4);

    //     str << matrix.name;
    //     char zeros[8] = {0};
    //     str.write(zeros, (8 - matrix.name.size()) % 8);

    //     char more_headers[4] = {9, 0, 0, 0};
    //     str.write(more_headers, 4);
    //     uint32_t data_byte_count = matrix.data.size() * 2 * 8;
    //     str.write((char *)&data_byte_count, 4);

    //     for (const auto &val : matrix.data)
    //     {
    //         str.write((char *)&val.first, 8);
    //         str.write((char *)&val.second, 8);
    //     }

    //     return str;
    // }
} // namespace mat