#include <iostream>
#include <memory>
#include <spdlog/spdlog.h>
#include <thread>
#include <chrono>

#include "connection.h"
#include "scope.h"
#include <fstream>
#include <sstream>
#include <spdlog/fmt/ostr.h>

struct mat_header
{
    friend std::ostream& operator<<(std::ostream& str, const mat_header&)
    {
        std::string text = "MATLAB 5.0 MAT-file. Generated by scope_receiver";
        text.resize(116);

        str.write(&*text.cbegin(), text.size());
        const char zeros[8] = {'\0'};
        uint16_t version = 0x0100;
        uint16_t BOM_mark = ('M' << 8) | 'I';

        str.write(zeros, 8);
        str.write((char*)&version, 2);
        str.write((char*)&BOM_mark, 2);
        return str;
    }
};

struct matrix
{
    const std::string& name;
    const std::vector<std::pair<double, double>>& data;

    friend std::ostream& operator<<(std::ostream& str, const matrix& matrix)
    {
        uint32_t type = 0x0e; // matrix
        uint32_t size = 24 /* header size */ + 8 /* dimensions size */ + 8 /* name dimensions size */;
        size += matrix.name.size();
        size += (8 - matrix.name.size()) % 8;
        size += 8 /* data type and something? */;
        size += 16 * matrix.data.size();

        str.write((char*)&type, 4);
        str.write((char*)&size, 4);

        char some_headers[24] = { 6,0,0,0, 8,0,0,0, 6,0,0,0, 0,0,0,0, 5,0,0,0,8,0,0,0 };
        str.write(some_headers, 24);

        uint32_t rows = 2;
        uint32_t cols = matrix.data.size();
        str.write((char*)&rows, 4);
        str.write((char*)&cols, 4);

        rows = 1;
        cols = matrix.name.size();
        str.write((char*)&rows, 4);
        str.write((char*)&cols, 4);

        str << matrix.name;
        char zeros[8] = {0};
        str.write(zeros, (8 - matrix.name.size()) % 8);

        char more_headers[4] = { 9,0,0,0 };
        str.write(more_headers, 4);
        uint32_t data_byte_count = matrix.data.size() * 2 * 8;
        str.write((char*)&data_byte_count, 4);

        for (const auto& val : matrix.data)
        {
            str.write((char*)&val.first, 8);
            str.write((char*)&val.second, 8);
        }

        return str;
    }
};

void read_channel_data(rigol::scope& scope, rigol::channel ch, std::vector<std::pair<double, double>>& data)
{
    std::vector<uint8_t> buffer;
    scope.select_channel(ch);
    scope.read_buffer(buffer);

    double x_origin = scope.x_origin();
    double x_increment = scope.x_increment();
    double x_reference = scope.x_reference();

    double y_origin = scope.y_origin();
    double y_increment = scope.y_increment();
    double y_reference = scope.y_reference();

    data.resize(buffer.size());

    for (size_t i = 0; i < 10; i++)
        spdlog::debug("byte({}) = {:d}", i, buffer[i]);

    for (size_t i = 0; i < buffer.size(); i++)
    {
        data[i].first = x_origin + (i - x_reference)*x_increment;
        data[i].second = (buffer[i] - y_reference - y_origin) * y_increment;
    }
    spdlog::info("Read {} items", data.size());
}

int main(int argc, char**argv)
{
    spdlog::set_level(spdlog::level::info);

    try
    {
        rigol::scope scope(std::make_unique<rigol::tcp_connection>("10.10.102.158", 5555));
        scope.single();
        std::this_thread::sleep_for(std::chrono::milliseconds(400));
        
        spdlog::info("Waiting for trigger");
        
        while (scope.get_trigger_state() != rigol::trigger_state::STOP)
            ;


        std::vector<std::pair<double, double>> data;
        // for (size_t i = 0; i < 100; i++)
        //     data.emplace_back(i*1.0, i*0.01);
        
        std::ofstream file("out.mat", std::ios::binary | std::ios::trunc | std::ios::out);
        file << mat_header{};

        for (auto ch : std::initializer_list{
            rigol::channel::CHANNEL_1,
            rigol::channel::CHANNEL_2,
            rigol::channel::CHANNEL_3,
            rigol::channel::CHANNEL_4,
        }) {
            spdlog::info("Reading data for {}", ch);
            read_channel_data(scope, ch, data);

            spdlog::info("Saving data for {}", ch);
            file << matrix{fmt::format("{}", ch), data};
        }

        spdlog::info("Done");
    }
    catch (const std::exception& ex)
    {
        spdlog::error("Error caught: {}", ex.what());
    }
    
    return 0;
}